	0220
플레이어 데미지 받을 때 화면을 깜빡이기(Blood Screen)
씬이동 -> 마지막 씬에 갔을 때 KillCount 표시
	게임 종료할지 다시할지 선택
OffMeshLink: 끊어진 매쉬를 잇는다(쫓아올 때 언덕 뛰어내리기)
NavMeshObstacle: 장애물을 피해다님
	0222
github 저장소 생성 -> github 홈페이지
your profile -> 레포지토리
github 저장소 클론 -> source tree
commit(저장)
Add(스테이지에 올리기)
push
git이란? version control sys
	// 버전 관리 시스템
add 스테이지에 올린다
push 업로드
https://github.com/sbn04043/helloAtentsUnity

	0223
crossfade(애니메이션 명, 시간)
직전 동작애니메이션과 지금 애니메이션을 0.3초동안 혼합해
부드러운 애니메이션을 만듦

	0224
c++: 전역이란 개념 X
	구조체 class

뷰포트: 모니터 기준으로(0.5, 0.5)는 중앙
스크린 포인트: 
magnitude: 거리 구하기 함수
coroutine 함수
blend: 부드럽게
벡터 내적 외적 삼각함수 공부

	0228
플레이어: 레거시
적: 메카닉
총발 발사 방식
  1. projectileMovement 오브젝트에 콜라이더 리지드 다는 방식
	단점: 동적할당 했다가 소멸하는 방식
	메모리 과부하가 일어날 수 있음
	-> 게임이 느려짐
	-> 오브젝트 풀링 방식을 사용(추후에 설명)
  2. RayCast(광선 발사) 
	메모리 부하 발생 X
	물리를 적용하려면 일일히 스크립트 작성

	0303
깃허브 사용 방법
Add: 스테이지 올리기
Commit: save
push: 저장소에 업로드
코드 뭉치 버리기
오브젝트 풀링: 동적으로 할당했다가 소멸하는 방식은 과부하 되기 쉬움
		이유는 C# 컴파일러에 가비지 컬렉터(메모리관리)라는 것이 있어서
		일정기간이 지나서 메모리를 한꺼번에 수거해가기 때문에 과부하가 생김
		미리 몇개 생성시켜 놓았다 오브젝트를 활성화 비활성화해서
		처음에는 메모리가 들지만 안정적인 메모리 관리가 됨

